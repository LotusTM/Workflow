
LotusTM development workflow
============================

В данном документе описаны основные принципы разработки в среде команды LotusTM


Термины и транслитерация
------------------------

`<placeholder>`


IDE
---

Для разработки может использоваться любой IDE, однако важным требованием является поддержка [EditorConfig](http://editorconfig.org/) для сохранения консистентности отображения и редактирования файлов в рамках данной рабочей среды.


Git
---

Для версирования используется [Git](http://git-scm.com/).

Основными средствами для работы с Git являются [SmartGitHg](http://www.syntevo.com/smartgithg/) и [Github](https://github.com/).


# Scaffolding

Репозитарий имеет структуру следующего вида:

```
├── app — основное приложение
│   ├── assets — статические элементы*
│   │   ├── fonts
│   │   ├── images
│   │   └── ...
|   ├── css
|   ├── js
|   └── ...
├── src — исходные файлы для компиляции
│   ├── fonts
│   ├── images
│   ├── js
│   │   └── *.js
│   ├── sass
│   |   └── *.scss
│   └── templates
│       └── *.twig
├── ...
├── package.json
├── README.md
├── .editorconfig
└── .gitignore
```

_\* как правило, ассеты вынесены на поддомен и подключены субмодулем для оптимизации процессов деплоя и уменьшения размера основного рабочего репозитария_


### Ветки

Во время разработки в среде Git используются две ветки:

* `develop` — основная ветка для проведения разработок. Любые изменения кода должны производиться именно в этой ветке;

* `master` — ветка для production-версии приложения, которая автоматически разворачивается на production-сервере и содержит *только* релизы. За коммит в `master`-ветку будут отрезаться руки и убиваться невинные котики.

При необходимости можно применять методологию [GitFlow](http://nvie.com/posts/a-successful-git-branching-model/).


### Коммиты

Все коммиты должны быть написаны:

1. на корректном английском языке;
2. в прошедшем времени;
3. преимущественно прописными буквами;
4. с корректной пунктуацией;
5. без точки в конце.

Все коммиты должны содержать следующие структурные элементы в линейном порядке:

1. дефис и пробел: `- `;
2. инлайн-тэг или инлайн-тэги вида `[html]`;
3. пробел;
4. краткое описание изменений в коммите с маленькой буквы и без точки в конце;
5. в случаи наличия референса к определенной задаче в Redmine — отделенные от описания коммита запятой статус и номер задачи в виде `, fixes #123`.

	Issue-трекер принимает следующие статусы:
	* `ref #123` или `ref,refs,references,issue` — устанавливает связь между коммитом и задачей;
	* `fix #123` или `fix,fixes,fixed,closes,closed` — отмечает указанную задачу решенной.

В результате коммит будет иметь следующий вид:

```
- [html] removed IE conditional comments, fixes #123
```

Инлайн-тэги используются для дифференциации коммитов в репозитарии.

В большинстве случаев инлайн-тэг должен содержать расширение файла или файлов, которые были изменены. Исключением являются файлы `.scss`, для которых инлайн-тэгом является `[sass]`.

В случае комплексных изменений определенных групп, когда разделение на меньшие коммиты является необоснованным, с целью выделить отношение данных комитов к определенной группе могут использоваться инлайн-тэги, которые содержат названия таких груп в строчном виде.

Примерами таких групп могут быть `[git]`, `[craft]`.

Список зарезервированных наименований для групп:
* `[git]` — для изменений в файлах Git;
* `[craft]` — для изменений в файлах Craft CMS;
* `[sass-framework]` — для изменений в файлах [SASS Framework](https://github.com/ArmorDarks/sass-framework);
* `[submodule]` — для изменений в субмодулях;
* `[misc]` — для общих изменений;
* _to be continued..._

Кроме того, в случаях комплексных изменений, с целью не потерять целостность работы и подчеркнуть тот факт, что коммит содержит монолитные изменения, при разделении которых может быть утрачена целостность картина, в одном коммите могут использоваться несколько инлайн-тэгов без разделения их пробелами. Например, `[html][sass]`.

Для обновлений субмодулей должен использоваться инлайн-тэг `[submodule]` и тэг элемента, который обновляется. Например, `[submodule][sass-framework]`.

Для  обозначения любых изменений в репозитарии, связанных с перемещениями, переименованиями, а также работой с любой документацией должен использоваться инлайн-тэг `[misc]`.

Элементы или блоки верстки, кода и подобные наименования должны быть выделены `` ` `` с двух сторон. Например `` `index-header` ``. Классы или переменные, несущие перед собой идентифицирующий элемент могут писаться без подобного выделения. Например, `.index-header` или `$some-variable`. Такой подход позволяет, например, отличить блок html-кода с определенным наименованием от класса с идентичным наименованием из CSS.

В случае необходимости, после краткого описания изменений в коммите через точку могут быть приведены важные заметки или предупреждения разработчика. Заметки должны начинаться с `Note:`, а предупреждения — с `Caution!`.

К примеру

```
- [html] removed IE conditional comments. Caution! No more IE6-7 support
```

В заметках и предупреждениях должна содержаться только действительно важная информация для данного коммита. В ином случае следует использовать issues-трекер.


#### Бинарные файлы

В большинстве случаев в репозитарии предусмотрен специальный субмодуль для ассетов, потому прежде чем делать коммит с любым видом бинарных файлов — убедитесь, что конвенцией по работе с данным репозитарием это разрешено. Если Вы не уверены куда корректней в данном случае запушить такой файл — уточните этот момент у лида.


#### Тэги

Git-тэги используются только для определения версии релиза с применением [Semantic Versioning 2.0.0](http://semver.org/spec/v2.0.0.html).



Issues-трекер
-------------

В качестве issues-трекера используется [Redmine](http://tasks.2bad.me/)


### Трекеры

В процессе работы используется 3 типа трекеров:

* `разработка` — предназначен для первоначальных разработок. Все, что создается с нуля, должно быть помещено в данный трекер;

* `улучшение` — предназначен для улучшений и доработок уже существующих элементов/объектов/кода, даже если они подлежат полному изменению;

* `ошибка` — предназначен для трекинга *именно* ошибок. Любые задачи касательно доработки или устранения недоработок должны быть помещены в трекер `улучшение`.


### Roadmap

Для разделения работы на критические этапы работы используется **roadmap** в Redmine:

* `*stage-name*` — обозначение вех работ.

	В качестве наименований вех используются [Semantic Versioning 2.0.0](http://semver.org/spec/v2.0.0.html)

	В каждую веху включается план задач на 1 этап работ.

* `unplanned` — содержит все фичи, улучшения или изменения, которые не входят ни в один из этапов запланированных работ. Служит бэк-логом. В последствии фичи из данного roadmap должны быть перенесены в один из запланированных этапов, или же отклонены и закрыты.

В зависимости от важности задачи создаются либо в рамках текущего roadmap, либо в `unplanned`.


### Задачи

Задачи создаются лидом, а в случае поступления задачи через иной коммуникационный канал (email, skype) — *самим исполнителем*.

Назначение **исполнителя** для задачи является обязательным за исключением ситуаций, когда еще неизвестно кто будет являться исполнителем настоящей задачи.

**Заголовок** задачи должен коротко, но ясно описывать суть задачи.

**Описание задачи** является ситуационным.

Кроме того, каждая задача должна:

1. быть помещена в соответствующий **трекер**;
2. быть помещена в соответствующий **roadmap**;
3. относиться к определенной **родительской задаче**, если таковая имеется;
4. содержать соответствующую **категорию**;
5. иметь соответствующий **статус**.


#### Категории задач

Для дифференциации задач используются следующие категории:

* `Feature`
* `Design` — дизайн любого типа;
* `Markup` — верстка html-кода;
* `Assets` — фото, тексты и так далее;
* `Frontend` — любой вид кодинга, связаный с frontend, кроме верстки html-кода;
* `Backend` — любой вид кодинга, связаный с backend, кроме верстки html-кода;
* `Server` — любые работы с сервером;
* `Workflow` — git, github, конфигурация репозиториев и среды разработки;
* `без категории` — задачи, которые не могут быть отнесены к определенной категории или будут отнесены к какой-то категории позже, а также ошибки.


#### Группирование задач

Комплексные задачи должны быть сгруппированы. Для этого используется родительская задача с общим описанием задачи, к которой прикрепляются дочерние задачи с описанием конкретных задач по данном тикету.

Родительской задачей всегда является фича или ошибка, которая может иметь дочерние задачи с разными категориями.

Задачи могут быть свзяаны между собой релейшенами

Как правило, в рамках roadmap по умолчанию создается следующая структура, которой следует придерживаться:

```
├── Фича
│   ├── комплексный элемент фичи
│   │   └── перечень работ по данному элементу
│   └── любые задачи касательно данной фичи, которые не являются комплексными
└── задачи, которые не входят ни в одну из выше перечисленных групп
    └── подзадачи
```

Задачи, у которых есть несколько исполнителей, разбиваются на задачи с указанием конкретных задач для каждого исполнителя и присоединяются к общей основной задаче в качестве дочерних задач.


#### Статусы задач

В момент создания задаче выставляется статус `Новый`

В момент начала работ над данной задачей исполнитель выставляет ему статус `В работе`. Данный статус сохраняется до полного решения данной задачи или её отклонения.

В случае необходимости получения комментария по задачей ей выставляется статус `Обратная связь` до момента получения обратной связи.

В результате решения задачи *исполнителем* выставляется статус `Решено` или `Отклонено` в зависимости от результата.

Статус `Закрыт` выставляется только принимающей стороной (как правило, лидом).


Кодинг
------

`<placeholder>`


Верстка
-------

`<placeholder>`


Дизайн
------

`<placeholder>`